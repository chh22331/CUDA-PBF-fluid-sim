#define NOMINMAX
#include <cstdio>
#include <vector>
#include <cstdint>
#include <cstdlib>
#include <windows.h>
#include <windowsx.h>
#include <chrono>
#include <cmath>
#include <string> 
#include <algorithm>

#include "engine/core/config.h"
#include "engine/core/profiler.h"
#include "engine/gfx/renderer.h"
#include "engine/core/console.h"
#include "engine/core/prof_nvtx.h"
#include "sim/simulator.h"
#include "sim/parameters.h"

// ---- Debug å…¨å±€çŠ¶æ€ä¸å·¥å…· ----
static bool g_DebugEnabled = false;
static bool g_DebugPaused = false;
static bool g_DebugStepRequested = false;

// ä½¿ç”¨ GetAsyncKeyState è½®è¯¢ï¼›åªåœ?app_main.cpp ä¸­åŒ…å?windows.h å·²æ»¡è¶³ä¾èµ?
static inline bool KeyDown(int vk) {
    return (GetAsyncKeyState(vk) & 0x8000) != 0;
}

// æ›´æ–°çª—å£æ ‡é¢˜æ ï¼ˆç²’å­æ•?+ FPSï¼?
static void UpdateWindowTitleHUD(HWND hwnd, uint32_t particleCount, double fps) {
    wchar_t buf[256];
    if (fps < 1e-3) fps = 0.0;
    swprintf(buf, L"PBF-X | N=%u | FPS=%.1f", particleCount, fps);
    SetWindowTextW(hwnd, buf);
}

// ä¸Šå‡æ²¿è§¦å‘ï¼ˆå»æŠ–ï¼?
static bool KeyPressedOnce(int vk) {
    static uint8_t prev[512] = {};
    vk &= 0x1FF; // ç®€å•é™ç•?
    bool down = KeyDown(vk);
    bool fired = down && (prev[vk] == 0);
    prev[vk] = down ? 1 : 0;
    return fired;
}

// ç®€æ˜?float3 å·¥å…·
static inline float3 f3_make(float x, float y, float z) { return make_float3(x, y, z); }
static inline float3 f3_add(const float3& a, const float3& b) { return f3_make(a.x + b.x, a.y + b.y, a.z + b.z); }
static inline float3 f3_sub(const float3& a, const float3& b) { return f3_make(a.x - b.x, a.y - b.y, a.z - b.z); }
static inline float3 f3_scale(const float3& a, float s) { return f3_make(a.x * s, a.y * s, a.z * s); }
static inline float  f3_dot(const float3& a, const float3& b) { return a.x * b.x + a.y * b.y + a.z * b.z; }
static inline float3 f3_cross(const float3& a, const float3& b) {
    return f3_make(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
}
static inline float  f3_len(const float3& a) { return std::sqrt(f3_dot(a, a)); }
static inline float3 f3_norm(const float3& a) {
    float l = f3_len(a); return (l > 1e-20f) ? f3_scale(a, 1.0f / l) : f3_make(0, 0, 0);
}

// è‡ªç”±é£è¡Œç›¸æœº
struct FreeFlyCamera {
    float3 position{};
    double yaw = 0.0;    // ç»•ä¸–ç•?Y
    double pitch = 0.0;  // ç»•ç›¸æœ?X
    float  moveSpeed = 1.0f;        // åŸºç¡€ç§»åŠ¨é€Ÿåº¦ï¼ˆå•ä½?ç§’ï¼‰
    float  mouseSensitivity = 0.002f; // å¼§åº¦/åƒç´ 
};

static FreeFlyCamera g_Camera;
static FreeFlyCamera* g_cam = nullptr;
static bool  g_RmbDown = false;
static POINT g_LastMouse{};
static float g_PendingWheel = 0.0f;

// yaw/pitch -> å‰å‘/å?ä¸?
static inline float3 CamForward(const FreeFlyCamera& c) {
    float cp = std::cos((float)c.pitch), sp = std::sin((float)c.pitch);
    float cy = std::cos((float)c.yaw), sy = std::sin((float)c.yaw);
    // yaw=0 æŒ‡å‘ +Zï¼›pitch æ­£å‘ä¸?
    return f3_norm(f3_make(sy * cp, sp, cy * cp));
}
static inline void CamBasis(const FreeFlyCamera& c, float3& fwd, float3& right, float3& up) {
    const float3 worldUp = f3_make(0.f, 1.f, 0.f);
    fwd = CamForward(c);
    right = f3_norm(f3_cross(fwd, worldUp));
    up = f3_cross(right, fwd);
}

// ä»?cc åˆå§‹åŒ–ç›¸æœºï¼ˆä¿æŒå½“å‰è§†è§’ï¼?
static FreeFlyCamera MakeCameraFromCc(const console::RuntimeConsole& cc) {
    FreeFlyCamera cam{};
    cam.position = cc.renderer.eye;
    float3 fwd = f3_norm(f3_sub(cc.renderer.at, cc.renderer.eye));
    // åè§£ yaw/pitch
    cam.pitch = std::asin(std::clamp((double)fwd.y, -1.0, 1.0));
    cam.yaw = std::atan2((double)fwd.x, (double)fwd.z);
    cam.moveSpeed = 1.0f; // å¯åŠ¨åæ ¹æ®åŸŸå°ºå¯¸å†è°ƒæ•?
    return cam;
}

// æ ¹æ®åŸŸå°ºåº¦è®¾å®šåŸºç¡€é€Ÿåº¦ï¼ˆå¯¹ 10x10x10 åŸŸç»™ ~3.0ï¼?
static float ComputeBaseSpeedFromDomain(const float3& mins, const float3& maxs) {
    float3 ext = f3_sub(maxs, mins);
    float  diag = f3_len(ext);
    return (((0.3f) > (diag * 0.3f)) ? (0.3f) : (diag * 0.3f));
}

// æ¯å¸§æ›´æ–°ï¼ˆé”®ç›?æ»šè½®ï¼‰ï¼ŒdtSec ç”¨å®æ—¶é—´éš?
static void UpdateFreeFlyCamera(FreeFlyCamera& cam, float dtSec) {
    float3 fwd, right, up;
    CamBasis(cam, fwd, right, up);

    // ç´¯ç§¯çš„æ»šè½®æ¨æ‹?
    if (std::abs(g_PendingWheel) > 1e-4f) {
        float dolly = g_PendingWheel * 0.0025f * cam.moveSpeed; // ç»éªŒç³»æ•°
        cam.position = f3_add(cam.position, f3_scale(fwd, dolly));
        g_PendingWheel = 0.0f;
    }

    // é”®ç›˜ç§»åŠ¨
    auto down = [](int vk) -> bool { return (GetAsyncKeyState(vk) & 0x8000) != 0; };
    float3 move = f3_make(0, 0, 0);
    if (down('W')) move = f3_add(move, fwd);
    if (down('S')) move = f3_sub(move, fwd);
    if (down('D')) move = f3_add(move, right);
    if (down('A')) move = f3_sub(move, right);
    if (down('E')) move = f3_add(move, up);
    if (down('Q')) move = f3_sub(move, up);

    float speedMul = 1.0f;
    if (down(VK_SHIFT)) speedMul *= 5.0f;
    if (down(VK_CONTROL)) speedMul *= 0.2f;

    if (f3_len(move) > 0.0f) {
        move = f3_norm(move);
        cam.position = f3_add(cam.position, f3_scale(move, cam.moveSpeed * speedMul * dtSec));
    }
}

// å°†ç›¸æœºåŒæ­¥åˆ°æ¸²æŸ“å™¨ï¼ˆæ¯å¸§è°ƒç”¨ï¼?
static void SyncCameraToRenderer(console::RuntimeConsole& cc, gfx::RendererD3D12& renderer, const FreeFlyCamera& cam) {
    float3 fwd, right, up;
    CamBasis(cam, fwd, right, up);
    cc.renderer.eye = cam.position;
    cc.renderer.at = f3_add(cam.position, fwd);
    cc.renderer.up = up;
    console::ApplyRendererRuntime(cc, renderer);
}

static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) {
    switch (msg) {
    case WM_SIZE:
        if (wp != SIZE_MINIMIZED) {
            uint32_t w = LOWORD(lp), h = HIWORD(lp);
            gfx::RendererD3D12* r = reinterpret_cast<gfx::RendererD3D12*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
            if (r) r->Resize(w, h);
        }
        break;
    case WM_RBUTTONDOWN:
        g_RmbDown = true;
        SetCapture(hwnd);
        g_LastMouse.x = GET_X_LPARAM(lp);
        g_LastMouse.y = GET_Y_LPARAM(lp);
        ShowCursor(FALSE);
        break;
    case WM_RBUTTONUP:
        g_RmbDown = false;
        ReleaseCapture();
        ShowCursor(TRUE);
        break;
    case WM_MOUSEMOVE:
        if (g_RmbDown && g_cam) {
            POINT p{ GET_X_LPARAM(lp), GET_Y_LPARAM(lp) };
            int dx = p.x - g_LastMouse.x;
            int dy = p.y - g_LastMouse.y;
            g_LastMouse = p;
            g_cam->yaw += (double)dx * g_cam->mouseSensitivity;
            g_cam->pitch += (double)(-dy) * g_cam->mouseSensitivity; // é¼ æ ‡ä¸Šç§» -> æŠ¬å¤´
            const double kLim = 1.5533; // ~89åº?
            if (g_cam->pitch > kLim) g_cam->pitch = kLim;
            if (g_cam->pitch < -kLim) g_cam->pitch = -kLim;
        }
        break;
    case WM_MOUSEWHEEL:
        g_PendingWheel += (float)GET_WHEEL_DELTA_WPARAM(wp); // ç´¯ç§¯ï¼Œç¨ååœ¨å¸§æ›´æ–°ä¸­æ¶ˆè´¹
        break;
    case WM_KILLFOCUS:
        if (g_RmbDown) {
            g_RmbDown = false;
            ReleaseCapture();
            ShowCursor(TRUE);
        }
        break;
    case WM_DESTROY:
        PostQuitMessage(0); return 0;
    }
    return DefWindowProcW(hwnd, msg, wp, lp);
}

static HWND CreateSimpleWindow(uint32_t w, uint32_t h, HINSTANCE hInst) {
    WNDCLASSW wc{}; wc.lpfnWndProc = WndProc; wc.hInstance = hInst; wc.lpszClassName = L"PBFxWnd";
    RegisterClassW(&wc);
    RECT rc{ 0,0,(LONG)w,(LONG)h }; AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, FALSE);
    HWND hwnd = CreateWindowW(wc.lpszClassName, L"PBF-X", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
        CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInst, nullptr);
    return hwnd;
}

// é«˜å¼€é”€â€œå¡Œé™·è¯Šæ–­â€ï¼šæ‰“å°å?cc.debug.printWarnings æ§åˆ¶ï¼Œæ‰§è¡Œå— cc.debug.enableAdvancedCollapseDiag æ§åˆ¶
static void LogAdvancedCollapseDiagnostics(const console::RuntimeConsole& cc, sim::Simulator& simulator, const sim::SimParams& simParams, core::Profiler& profiler) {
    const uint32_t N = simParams.numParticles;
    if (N == 0) return;

    const float4* d_pos = simulator.devicePositions();
    if (!d_pos) return;

    const uint32_t sampleStride = (cc.debug.advancedCollapseSampleStride >= 1)
        ? (uint32_t)cc.debug.advancedCollapseSampleStride
        : 16u;

    std::vector<float4> h_pos(N);
    if (cudaMemcpy(h_pos.data(), d_pos, sizeof(float4) * N, cudaMemcpyDeviceToHost) != cudaSuccess) {
        if (cc.debug.printWarnings) {
            std::fprintf(stderr, "[Diag] cudaMemcpy positions failed.\n");
        }
        return;
    }

    // å­é‡‡æ ?
    std::vector<float3> pts;
    pts.reserve((N + sampleStride - 1) / sampleStride);
    for (uint32_t i = 0; i < N; i += sampleStride) {
        pts.push_back(make_float3(h_pos[i].x, h_pos[i].y, h_pos[i].z));
    }
    const size_t M = pts.size();
    if (M < 2) return;

    // è´¨å¿ƒ
    double sx = 0, sy = 0, sz = 0;
    for (auto& p : pts) { sx += p.x; sy += p.y; sz += p.z; }
    const double invM = 1.0 / double(M);
    const double comx = sx * invM, comy = sy * invM, comz = sz * invM;

    // å›¢ç°‡åŠå¾„ï¼ˆRMS / Maxï¼?
    double sumR2 = 0.0; double maxR = 0.0;
    for (auto& p : pts) {
        const double dx = p.x - comx, dy = p.y - comy, dz = p.z - comz;
        const double r = std::sqrt(dx * dx + dy * dy + dz * dz);
        sumR2 += r * r;
        if (r > maxR) maxR = r;
    }
    const double rmsR = std::sqrt(sumR2 * invM);

    // æœ€è¿‘é‚»è·ç¦»
    std::vector<float> nn;
    nn.resize(M);
    for (size_t i = 0; i < M; ++i) {
        double best2 = 1e300;
        const double xi = pts[i].x, yi = pts[i].y, zi = pts[i].z;
        for (size_t j = 0; j < M; ++j) {
            if (j == i) continue;
            const double dx = xi - pts[j].x;
            const double dy = yi - pts[j].y;
            const double dz = zi - pts[j].z;
            const double d2 = dx * dx + dy * dy + dz * dz;
            if (d2 < best2) best2 = d2;
        }
        nn[i] = (best2 > 0.0) ? float(std::sqrt(best2)) : 0.0f;
    }
    std::sort(nn.begin(), nn.end());
    auto pct = [&](double q) -> float {
        if (nn.empty()) return 0.0f;
        double idx = q * (nn.size() - 1);
        size_t i0 = size_t(std::floor(idx));
        size_t i1 = (((i0 + 1) < (nn.size() - 1)) ? (i0 + 1) : (nn.size() - 1));
        double t = idx - i0;
        return float((1.0 - t) * nn[i0] + t * nn[i1]);
    };
    const float nnMin = nn.front();
    const float nnMed = pct(0.5);
    const float nnP05 = pct(0.05);
    const float nnP95 = pct(0.95);

    // é˜ˆå€¼æ¯”ä¾‹ï¼ˆè¶Šå¤§è¶Šæ¥è¿‘â€œå¡Œé™?é‡å â€ï¼‰
    const float h = simParams.kernel.h;
    const float th05 = 0.05f * h;
    const float th10 = 0.10f * h;
    size_t cnt05 = 0, cnt10 = 0;
    for (float d : nn) { if (d <= th05) ++cnt05; if (d <= th10) ++cnt10; }
    const double frac05 = double(cnt05) / double(M);
    const double frac10 = double(cnt10) / double(M);

    // å†™å…¥ CSVï¼ˆæ•´å‹ç¼©æ”¾ï¼‰
    profiler.addCounter("collapse_rms_radius_over_h_x1000", (int64_t)llround((rmsR / h) * 1000.0));
    profiler.addCounter("collapse_max_radius_over_h_x1000", (int64_t)llround((maxR / h) * 1000.0));
    profiler.addCounter("nn_min_over_h_x1000", (int64_t)llround((nnMin / h) * 1000.0));
    profiler.addCounter("nn_p05_over_h_x1000", (int64_t)llround((nnP05 / h) * 1000.0));
    profiler.addCounter("nn_median_over_h_x1000", (int64_t)llround((nnMed / h) * 1000.0));
    profiler.addCounter("nn_p95_over_h_x1000", (int64_t)llround((nnP95 / h) * 1000.0));
    profiler.addCounter("frac_nn_le_0p05h_permille", (int64_t)llround(frac05 * 1000.0));
    profiler.addCounter("frac_nn_le_0p10h_permille", (int64_t)llround(frac10 * 1000.0));

    // äººç±»å¯è¯»çš„é˜ˆå€¼æŠ¥è­¦ï¼ˆå?printWarnings æ§åˆ¶ï¼?
    if (cc.debug.printWarnings) {
        if ((rmsR / h) < 0.15 && frac05 > 0.30) {
            std::printf("[Warn] Collapse suspected: rmsR=%.3f h, maxR=%.3f h, nn_min=%.3f h, frac(nn<=0.05h)=%.1f%%, frac(nn<=0.1h)=%.1f%%\n",
                float(rmsR / h), float(maxR / h), float(nnMin / h), float(frac05 * 100.0), float(frac10 * 100.0));
        }
        else if (frac10 > 0.60) {
            std::printf("[Warn] Dense cluster: frac(nn<=0.1h)=%.1f%%, median_nn=%.3f h, rmsR=%.3f h\n",
                float(frac10 * 100.0), float(nnMed / h), float(rmsR / h));
        }
    }
}

// æœ€å°å®ˆé—¨é˜ˆå€¼æ ¡éªŒä¸é’³åˆ¶ï¼ˆçƒ­åŠ è½½åè°ƒç”¨ï¼‰
static void SanitizeRuntime(console::RuntimeConsole& cc, sim::SimParams& sp) {
    const bool log = cc.debug.printSanitize;
    // è¿­ä»£æ¬¡æ•°ï¼?..64
    if (sp.solverIters < 1) { sp.solverIters = 1; if (log) std::fprintf(stderr, "[Sanitize] solverIters clamped to 1\n"); }
    if (sp.solverIters > 64) { sp.solverIters = 64; if (log) std::fprintf(stderr, "[Sanitize] solverIters clamped to 64\n"); }
    // é‚»åŸŸä¸Šé™ï¼?..1024ï¼ˆå¹¶ä¸?perf.neighbor_cap ä¸€è‡´ï¼‰
    if (sp.maxNeighbors < 8) { sp.maxNeighbors = 8; if (log) std::fprintf(stderr, "[Sanitize] maxNeighbors clamped to 8\n"); }
    if (cc.perf.neighbor_cap > 0 && sp.maxNeighbors > cc.perf.neighbor_cap) {
        sp.maxNeighbors = cc.perf.neighbor_cap;
        if (log) std::fprintf(stderr, "[Sanitize] maxNeighbors clamped to perf.neighbor_cap=%d\n", cc.perf.neighbor_cap);
    }
    if (sp.maxNeighbors > 1024) { sp.maxNeighbors = 1024; if (log) std::fprintf(stderr, "[Sanitize] maxNeighbors clamped to 1024\n"); }
    // æ’åºé¢‘ç‡ï¼?=1
    if (sp.sortEveryN < 1) { sp.sortEveryN = 1; if (log) std::fprintf(stderr, "[Sanitize] sortEveryN clamped to 1\n"); }
    // è§†å›¾ç‚¹å¤§å°ï¼š0.5..32
    if (cc.viewer.point_size_px < 0.5f) { cc.viewer.point_size_px = 0.5f; if (log) std::fprintf(stderr, "[Sanitize] viewer.point_size_px clamped to 0.5\n"); }
    if (cc.viewer.point_size_px > 32.f) { cc.viewer.point_size_px = 32.f; if (log) std::fprintf(stderr, "[Sanitize] viewer.point_size_px clamped to 32\n"); }
}

static std::string MakeConfigAbsolutePath() {
    wchar_t buf[MAX_PATH] = {};
    DWORD n = GetModuleFileNameW(nullptr, buf, MAX_PATH);
    std::wstring exePath(buf, (n ? n : 0));
    size_t slash = exePath.find_last_of(L"\\/");
    std::wstring dir = (slash == std::wstring::npos) ? L"." : exePath.substr(0, slash);
    std::wstring wfull = dir + L"\\config.json";
    // è½?UTF-8
    int len = WideCharToMultiByte(CP_UTF8, 0, wfull.c_str(), (int)wfull.size(), nullptr, 0, nullptr, nullptr);
    std::string out(len, '\0');
    if (len > 0) {
        WideCharToMultiByte(CP_UTF8, 0, wfull.c_str(), (int)wfull.size(), &out[0], len, nullptr, nullptr);
    }
    return out;
}

int WINAPI wWinMain(HINSTANCE hInst, HINSTANCE, PWSTR, int) {
#ifdef ENABLE_NVTX
    nvtx3::scoped_range sr_main{ "Program.Main" };
#endif
    auto& cc = console::Instance();
    config::State cfgState{};
    {
        std::string cfgPath = MakeConfigAbsolutePath();
        std::string err;
        // å°è¯•ä»?exe åŒç›®å½•åŠ è½½ï¼›å¤±è´¥åˆ™æ²¿ç”¨é»˜è®?cc å€¼ç»§ç»­è¿è¡?
        if (!config::LoadFile(cfgPath, cc, &cfgState, &err) && !err.empty()) {
            std::fprintf(stderr, "Config load warning: %s\n", err.c_str());
        }
    }

    // 1) åº”ç”¨çª—å£ï¼ˆä½¿ç”¨é…ç½®ä¸­çš„åˆ†è¾¨ç‡/vsyncï¼?
    HWND hwnd = CreateSimpleWindow(cc.app.width, cc.app.height, hInst);

    // 2) æ¸²æŸ“å™¨åˆå§‹åŒ–
    gfx::RendererD3D12 renderer;
    SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)&renderer);

    gfx::RenderInitParams rp;
    console::BuildRenderInitParams(cc, rp);
    if (!renderer.Initialize(hwnd, rp)) return 1;
     
    console::ApplyRendererRuntime(cc, renderer);
    // Debug åˆå§‹åŒ–ï¼šé»˜è®¤å¼€å¯ï¼Œå¯åŠ¨å³æš‚å?
    g_DebugEnabled = cc.debug.enabled;
    g_DebugPaused = cc.debug.pauseOnStart && g_DebugEnabled;
    g_DebugStepRequested = false;
    g_Camera = MakeCameraFromCc(cc);
    g_Camera.moveSpeed = ComputeBaseSpeedFromDomain(cc.sim.gridMins, cc.sim.gridMaxs);
    g_cam = &g_Camera;

    core::Profiler profiler;
    if (cc.sim.demoMode == console::RuntimeConsole::Simulation::DemoMode::CubeMix) {
        console::PrepareCubeMix(cc); // åˆ†è§£ç²’å­ä¸åŸŸæ‹Ÿåˆ + é¢œè‰²
    }

    // 3) ä»¿çœŸåˆå§‹åŒ?
    sim::Simulator simulator;
    sim::SimParams simParams{};
    console::BuildSimParams(cc, simParams);
    SanitizeRuntime(cc, simParams);
    if (!simulator.initialize(simParams)) {
        MessageBoxW(hwnd, L"Simulator initialize failed.", L"PBF-X", MB_ICONERROR);
        return 1;
    }
    auto& c = console::Instance();
    // æ ¹æ®é…ç½®è®¾ç½® NVTX
    prof::SetNvtxEnabled(c.perf.enable_nvtx);
    // å¯é€‰ï¼šå•æ¬¡æ ‡è®°å¯åŠ¨é˜¶æ®µ
    prof::Mark("App.Startup", prof::Color(0xFF, 0x80, 0x20));


    // 4) D3D12-CUDA å…±äº«ç²’å­ç¼“å†²
    {
        const uint32_t capacity = (simParams.maxParticles > 0) ? simParams.maxParticles : simParams.numParticles;
        // ç§»é™¤æ—§çš„ cc.perf.use_external_pos_pingpong æ ‡å¿—ï¼šç»Ÿä¸€é‡‡ç”¨åŒç¼“å†?ping-pong
        HANDLE sharedA = nullptr, sharedB = nullptr;
        renderer.CreateSharedParticleBufferIndexed(0, capacity, sizeof(float4), sharedA);
        renderer.CreateSharedParticleBufferIndexed(1, capacity, sizeof(float4), sharedB);

        size_t bytes = size_t(capacity) * sizeof(float4);
        if (!simulator.bindExternalPosPingPong(sharedA, bytes, sharedB, bytes)) {
            std::fprintf(stderr, "[App][Error] bindExternalPosPingPong failed.\n");
        }
        CloseHandle(sharedA);
        CloseHandle(sharedB);

        HANDLE sharedVel = nullptr;
        if (renderer.CreateSharedVelocityBuffer(capacity, sizeof(float4), sharedVel)) {
            if (!simulator.bindExternalVelocityBuffer(sharedVel, bytes, sizeof(float4))) {
                std::fprintf(stderr, "[App][Warn] bindExternalVelocityBuffer failed.\n");
            }
        }
        else {
            std::fprintf(stderr, "[App][Warn] CreateSharedVelocityBuffer failed.\n");
        }
        if (sharedVel) CloseHandle(sharedVel);

        renderer.RegisterPingPongCudaPtrs(simulator.pingpongPosA(), simulator.pingpongPosB());
        renderer.SetParticleCount(simulator.activeParticleCount());
    }

    // Timeline fence binding (zero CPU polling)
    if (!simulator.bindTimelineFence(renderer.SharedTimelineFenceHandle())) {
        std::fprintf(stderr, "[App][Warn] bindTimelineFence failed, fallback to sequential usage.\n");
    }

    // 5) åˆå§‹å¸ƒç‚¹ - ä»?CubeMix æ¨¡å¼
    std::vector<float3> centers;
    console::GenerateCubeMixCenters(cc, centers);
    const uint32_t groups = cc.sim.cube_group_count;
    const uint32_t edge = cc.sim.cube_edge_particles;
    const float spacing = simParams.kernel.h *
        ((cc.sim.cube_lattice_spacing_factor_h > 0.f) ? cc.sim.cube_lattice_spacing_factor_h : 1.0f);

    // 7 å‚æ•°ç‰ˆæœ¬ï¼šæ”¯æŒå¯é€‰æŠ–åŠ¨ï¼ˆä½¿ç”¨ Simulation çš„åˆå§‹æŠ–åŠ¨å‚æ•°ï¼‰
    simulator.seedCubeMix(
        groups,
        centers.data(),
        edge,
        spacing,
        (cc.sim.cube_apply_initial_jitter && cc.sim.initial_jitter_enable),
        cc.sim.initial_jitter_scale_h * simParams.kernel.h,
        cc.sim.initial_jitter_seed
        );

    // ä¸Šä¼ è°ƒè‰²æ¿ä¸åˆ†ç»„å…ƒæ•°æ®ï¼ˆä¾?VS/PS ä½¿ç”¨ï¼?
    renderer.UpdateGroupPalette(&cc.sim.cube_group_colors[0][0], groups);
    renderer.SetParticleGrouping(groups, cc.sim.cube_particles_per_group);
    const uint32_t active = simulator.activeParticleCount();
    simParams.numParticles = active;
    renderer.SetParticleCount(active);
   
    uint64_t frameIndex = 0;
    MSG msg{};
    bool running = true;

    // çƒ­åŠ è½?è¯Šæ–­èŠ‚æµ
    const uint32_t hotReloadEveryNFrames =
        (cc.app.hot_reload && cc.app.hot_reload_every_n > 0)
        ? (uint32_t)cc.app.hot_reload_every_n
        : UINT32_MAX;

    // æ–°ï¼šç”¨äºç›¸æœº dtï¼ˆä¸Šä¸€å¸§ç»“æ?â†?æœ¬å¸§å¼€å§‹ï¼‰
    using Clock = std::chrono::steady_clock;
    static auto s_prevFrameEnd = Clock::now();

    // ================= è·‘åˆ†çŠ¶æ€?=================
    const bool benchEnabled = cc.bench.enabled;
    const int benchTotalFrames = cc.bench.total_frames;
    const double benchTotalSeconds = cc.bench.total_seconds;
    const bool benchUseTimeRange = cc.bench.use_time_range;
    const int sampleBeginFrame = cc.bench.sample_begin_frame;
    const int sampleEndFrameCfg = cc.bench.sample_end_frame; //å¯èƒ½ <0
    const double sampleBeginSec = cc.bench.sample_begin_seconds;
    const double sampleEndSecCfg = cc.bench.sample_end_seconds;

    auto wallStart = Clock::now(); // è·‘åˆ†æ•´ä½“èµ·å§‹æ—¶é—´

    // ç´¯è®¡æ•°æ®ï¼ˆåªç»Ÿè®¡é‡‡æ ·çª—å£å†…ï¼‰
    uint64_t benchSampledFrames = 0;
    double accumFrameMs = 0.0;
    double accumSimGpuMs = 0.0;
    double accumRenderMs = 0.0;
    double frameMsMin = 1e300, frameMsMax = 0.0;
    double simMsMin = 1e300, simMsMax = 0.0;
    double renderMsMin = 1e300, renderMsMax = 0.0;

    auto InFrameSampleWindow = [&](uint64_t frameIdx) -> bool {
        if (benchUseTimeRange) return false; // å¸§èŒƒå›´æ¨¡å¼ä¸‹æ‰èµ°è¿™é‡Œ
        if ((int64_t)frameIdx < sampleBeginFrame) return false;
        if (sampleEndFrameCfg >= 0 && (int64_t)frameIdx > sampleEndFrameCfg) return false;
        return true;
    };
    auto InTimeSampleWindow = [&](double elapsedSec) -> bool {
        if (!benchUseTimeRange) return false;
        if (elapsedSec < sampleBeginSec) return false;
        if (sampleEndSecCfg > 0.0 && elapsedSec > sampleEndSecCfg) return false;
        return true;
    };

    while (running) {
        while (PeekMessage(&msg, nullptr, 0, 0, PM_REMOVE)) {
            if (msg.message == WM_QUIT) running = false;
            TranslateMessage(&msg); DispatchMessage(&msg);
        }

        // å¸§å¼€å§‹æ—¶é—´ï¼ˆç”¨äº frame_msï¼?
        auto frameStart = Clock::now();
        double elapsedSec = std::chrono::duration<double>(frameStart - wallStart).count();

        // ==== è·‘åˆ†ç»“æŸæ¡ä»¶åˆ¤æ–­ï¼ˆå¾ªç¯é¡¶éƒ¨å³å¯æ—©åœï¼‰====
        if (benchEnabled) {
            bool reachedFrames = (benchTotalFrames > 0) && ((int64_t)frameIndex >= benchTotalFrames);
            bool reachedTime = (benchTotalSeconds > 0.0) && (elapsedSec >= benchTotalSeconds);
            if (reachedFrames || reachedTime) {
                running = false; //ç›´æ¥è·³å‡ºä¸»å¾ªç?
            }
        }
        if (!running) break; // é¿å…å¤šåšä¸€å¸?

        // çƒ­åŠ è½?
        if (hotReloadEveryNFrames != UINT32_MAX &&
            (frameIndex % hotReloadEveryNFrames) == 0) {
            std::string err;
            if (config::TryHotReload(cfgState, cc, &err)) {
                console::BuildSimParams(cc, simParams);
                SanitizeRuntime(cc, simParams);
                console::ApplyRendererRuntime(cc, renderer);
                if (cc.debug.printHotReload) {
                    std::printf("[HotReload] Applied profile=%s K=%d maxN=%d sortN=%d point_size=%.2f\n",
                        cfgState.activeProfile.c_str(), simParams.solverIters, simParams.maxNeighbors, simParams.sortEveryN, cc.viewer.point_size_px);
                }
            }
        }

        profiler.beginFrame(frameIndex);

        // å…ƒæ•°æ?
        profiler.addCounter("num_particles", (int64_t)simParams.numParticles);
        profiler.addCounter("solver_iters", simParams.solverIters);
        profiler.addCounter("max_neighbors", simParams.maxNeighbors);
        profiler.addCounter("sort_every_n", simParams.sortEveryN);
        profiler.addText("profile", cfgState.activeProfile);


    // ======= è·‘åˆ†ç»“æœè¾“å‡º =======
    if (benchEnabled) {
        double benchElapsedSec = std::chrono::duration<double>(Clock::now() - wallStart).count();
        if (benchSampledFrames > 0) {
            double avgFrame = accumFrameMs / benchSampledFrames;
            double avgSim = accumSimGpuMs / benchSampledFrames;
            double avgRender = accumRenderMs / benchSampledFrames;
            double fps = 1000.0 / avgFrame;
            std::printf("\n==== Benchmark Result ====\n");
            std::printf("SampledFrames: %llu\n", (unsigned long long)benchSampledFrames);
            std::printf("TotalElapsedSec: %.3f\n", benchElapsedSec);
            if (!benchUseTimeRange) {
                std::printf("FrameRange: [%d, %s]\n", sampleBeginFrame,
                    (cc.bench.sample_end_frame >= 0) ? std::to_string(cc.bench.sample_end_frame).c_str() : "end");
            } else {
                std::printf("TimeRangeSec: [%.3f, %s]\n", sampleBeginSec,
                    (cc.bench.sample_end_seconds > 0.0) ? std::to_string(cc.bench.sample_end_seconds).c_str() : "end");
            }
            std::printf("Frame_ms avg=%.3f min=%.3f max=%.3f\n", avgFrame, frameMsMin, frameMsMax);
            //std::printf("Sim_msGpu avg=%.3f min=%.3f max=%.3f\n", avgSim, simMsMin, simMsMax);
            //std::printf("Render_ms avg=%.3f min=%.3f max=%.3f\n", avgRender, renderMsMin, renderMsMax);
            std::printf("FPS_avg=%.2f\n", fps);
            std::printf("==========================\n");
        } else {
            std::printf("[Benchmark] No frames sampled (check window configuration).\n");
        }
    }

    simulator.shutdown();
    renderer.Shutdown();
    return 0;
}

int main() {
    return wWinMain(GetModuleHandleW(nullptr), nullptr, GetCommandLineW(), SW_SHOWNORMAL);
}
